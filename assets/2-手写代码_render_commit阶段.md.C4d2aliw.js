import{_ as o,c as d,a0 as c,o as r}from"./chunks/framework.BZW3-RJc.js";const h=JSON.parse('{"title":"render&commit阶段","description":"","frontmatter":{},"headers":[],"relativePath":"2-手写代码/render&commit阶段.md","filePath":"2-手写代码/render&commit阶段.md"}'),i={name:"2-手写代码/render&commit阶段.md"};function l(t,e,n,a,m,p){return r(),d("div",null,e[0]||(e[0]=[c('<h1 id="render-commit阶段" tabindex="-1">render&amp;commit阶段 <a class="header-anchor" href="#render-commit阶段" aria-label="Permalink to &quot;render&amp;commit阶段&quot;">​</a></h1><blockquote><p>本篇文章是在文章+手写期间的思路总结，是为了辅助文章和手写的产物，可能与最终的实现有所差异，也有可能有部分误差，请结合文章和手写代码仔细甄别（因为我懒得改了=_=）</p></blockquote><ul><li><code>render</code>阶段<code>beginWork</code>： <ul><li>构建fiber</li><li>fiber父子关系的绑定</li><li><code>reconcileChildFibers()</code>进行子节点的diff，因此需要<code>FunctionComponent</code>/<code>ClassComponent</code>进行渲染，才能拿到对应的children元素</li></ul></li><li><code>render</code>阶段<code>completeWork</code>: <ul><li>对于<code>HostComponent</code>进行处理：初始化instance + appendAllChildren()将所有子dom挂载在父dom上</li><li>对于<code>HostText</code>进行处理：初始化文本DOM，然后进行更新</li></ul></li><li><code>commit</code>阶段： <ul><li>直接使用原生的方法，比如appendChild、deleteChild等操作DOM，由于组件已经在render阶段构建完成，因此这里直接appendChild(dom)即可</li><li>调用对应的effect函数的里面的内容！也就是处理fiber.updateQueue的lastEffect等链表数据</li></ul></li></ul><p>初始化时，<code>beginWork</code>会阻止设置<code>Placement</code>的<code>flag</code>，然后在<code>completeWork</code>会进行<code>HostComponent</code>的处理：初始化instance + appendAllChildren()将所有子dom挂载在父dom上</p><p>但是更新时，<code>beginWork</code>不会阻止<code>Placement</code>的<code>flag</code>，然后在<code>completeWork</code>会进行<code>HostComponent</code>的处理：更新属性</p><p>而<code>beginWork</code>的<code>FunctionComponent</code>/<code>ClassComponent</code>无论是首次渲染/渲染更新，都会触发！</p><h2 id="render阶段" tabindex="-1">render阶段 <a class="header-anchor" href="#render阶段" aria-label="Permalink to &quot;render阶段&quot;">​</a></h2><p>当前fiber与fiber.children之间的切换依赖<code>completeUnitOfWork</code></p><ul><li>beginWork</li><li>completeWork</li></ul><h3 id="beginwork" tabindex="-1">beginWork <a class="header-anchor" href="#beginwork" aria-label="Permalink to &quot;beginWork&quot;">​</a></h3><p>主要根据<code>fiber.tag</code>调用不同的方法进行处理，核心方法最终都会调用<code>mountChildFibers</code>进行children元素的对比</p><ul><li>能够复用的数据，打上可以复用的flag</li><li>不能复用的数据，打上删除的flag</li><li>新增的数据，打上新增或者移动的flag</li></ul><p>最终构建出fiber树！并且fiber都打上了flags!</p><h3 id="completework" tabindex="-1">completeWork <a class="header-anchor" href="#completework" aria-label="Permalink to &quot;completeWork&quot;">​</a></h3><p>主要根据<code>fiber.tag</code>调用不同的方法进行处理，大部分直接返回null + 没做什么处理</p><p>但是对于<code>HostComponent</code>来说，会初始化dom + appendAllChildren()将所有子dom挂载在父dom上</p><p>这个阶段会初始化所有fiber的stateNode，并且绑定它们之间的关系，但是root不会跟它们绑定！因为要等到commit阶段root才会跟它们绑定！</p><h2 id="commit阶段" tabindex="-1">commit阶段 <a class="header-anchor" href="#commit阶段" aria-label="Permalink to &quot;commit阶段&quot;">​</a></h2><p>根据标签调整DOM之间的关系，该复用就复用、该插入就插入、该删除就删除、该新增就新增</p><p>最终将rootDom与这些dom关联起来，形成DOM树！</p>',20)]))}const f=o(i,[["render",l]]);export{h as __pageData,f as default};
