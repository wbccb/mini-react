import{_ as o,c as a,a0 as d,o as c}from"./chunks/framework.BZW3-RJc.js";const h=JSON.parse('{"title":"Scheduler手写思路","description":"","frontmatter":{},"headers":[],"relativePath":"2-手写代码/Scheduler实现思路.md","filePath":"2-手写代码/Scheduler实现思路.md"}'),l={name:"2-手写代码/Scheduler实现思路.md"};function t(s,e,i,u,r,k){return c(),a("div",null,e[0]||(e[0]=[d('<h1 id="scheduler手写思路" tabindex="-1">Scheduler手写思路 <a class="header-anchor" href="#scheduler手写思路" aria-label="Permalink to &quot;Scheduler手写思路&quot;">​</a></h1><h2 id="基本流程" tabindex="-1">基本流程 <a class="header-anchor" href="#基本流程" aria-label="Permalink to &quot;基本流程&quot;">​</a></h2><ol><li>新建一个task，处理startTime（根据options.delay判断是taskQueue内容还是timeQueue内容），处理expirationTime（根据优先级设置不同的过期时间），加入到对应的queue中</li><li>然后触发<code>requestHostCallback(flushWork)</code>: 进行boolean值锁的设置，<code>scheduledHostCallback=flushWork</code>，然后触发schedulePerformWorkUtilDeadLine()</li><li><code>schedulePerformWorkUtilDeadLine</code>: MessageChannel触发post.postMessage(null)</li><li>宏任务触发<code>performWorkUntilDeadline</code>: 执行之前<code>requestHostCallback</code>设置的callback(<code>scheduledHostCallback=flushWork</code>)进行执行，判断返回结果，如果返回结果显示hasWork(一般是时间不够导致的work包含的多个task没有执行完毕)，再次MessageChannel触发post.postMessage(null)</li><li><code>performWorkUntilDeadline</code> -&gt; <code>flushWork</code>，实际就是<code>workLoop()</code></li></ol><h2 id="宏任务具体内容" tabindex="-1">宏任务具体内容 <a class="header-anchor" href="#宏任务具体内容" aria-label="Permalink to &quot;宏任务具体内容&quot;">​</a></h2><p><code>flushWork</code>本质就是执行<code>workLoop</code> + 一些全局变量的重置 + 错误的处理</p><p><code>workLoop</code>:</p><ul><li>从<code>taskQueue</code>中不断取出<code>task</code>进行执行，首先设置task.callback=null</li><li>如果<code>task.callback</code>返回function，说明还没执行完毕，那么task.callback=continueCallback</li><li>如果<code>task.callback</code>没有返回function，执行完毕，则继续从<code>taskQueue</code>的栈顶取出<code>task</code>进行执行</li><li>在每一次可能的场景中，判断是否需要将<code>timeQueue</code>取出<code>task</code>放入到<code>taskQueue</code>进行执行（startTime是否已经到达）</li></ul><h3 id="workloop中断" tabindex="-1"><code>workLoop</code>中断 <a class="header-anchor" href="#workloop中断" aria-label="Permalink to &quot;`workLoop`中断&quot;">​</a></h3><p>当【<code>taskQueue</code>的栈顶元素<code>task.expirationTime</code>大于当前时间】 &amp;&amp; 【<code>!hasTimeRemaining || shouldYieldToHost()</code>没有时间可以继续执行任务】</p><blockquote><p>系统没有时间给你执行，而且当前任务还可以拖一拖的情况下，<code>hasWork=true</code>触发新一轮宏任务</p></blockquote><p>中断while循环，currentTask不为空，直接返回true，<code>hasWork=true</code>=&gt;再次<code>MessageChannel触发post.postMessage(null)</code></p><h3 id="workloop的taskqueue执行完毕后的处理-倒计时处理timerqueue" tabindex="-1"><code>workLoop</code>的<code>taskQueue</code>执行完毕后的处理-倒计时处理timerQueue <a class="header-anchor" href="#workloop的taskqueue执行完毕后的处理-倒计时处理timerqueue" aria-label="Permalink to &quot;`workLoop`的`taskQueue`执行完毕后的处理-倒计时处理timerQueue&quot;">​</a></h3><ul><li>新增task时：当<code>taskQueue</code>为空时，我们增加一个新的<code>task</code>，但是<code>task.startTime</code>大于当前时间，因此<code>taskQueue</code>不需要执行，这个时候进行倒计时，<code>timeQueue</code>的栈顶进行startTime-当前时间的setTimeout倒计时</li><li>workLoop执行时：当<code>taskQueue</code>为空时，<code>taskQueue</code>不需要执行，这个时候进行倒计时，<code>timeQueue</code>的栈顶进行startTime-当前时间的setTimeout倒计时</li></ul><p>使用<code>requestHostTimeout</code>传递处理函数<code>handleTimeout</code>+当前的倒计时ms</p><blockquote><p>注意两件事：我们调用requestHostTimeout时记得先取消掉原来的倒计时；新增task可能不是栈顶，需要进行判断！</p></blockquote><p><code>handleTimeout</code>主要负责两个事情：</p><ul><li>检测是否可以将timerQueue -&gt; taskQueue</li><li>如果目前有task，则触发<code>requestHostCallback(flushWork)</code>；如果没有task，说明timerQueue -&gt; taskQueue，这个task不知道为什么，在倒计时期间变为废弃的！则重新从timerQueue中获取栈顶进行倒计时</li></ul><h3 id="timerqueue-taskqueue的时机" tabindex="-1">timerQueue -&gt; taskQueue的时机 <a class="header-anchor" href="#timerqueue-taskqueue的时机" aria-label="Permalink to &quot;timerQueue -&gt; taskQueue的时机&quot;">​</a></h3><ul><li>当每次处理完一个task的时候，我们需要触发<code>advanceTimers</code>检测是否需要将timerQueue -&gt; taskQueue，比如刚开始触发workLoop，比如从taskQueue处理完成一个task之后</li><li>同时也存在timerQueue中有废弃数据的情况（通过timerTask.callback为null）进行数据的剔除</li></ul><h2 id="taskqueue二叉堆实现思路" tabindex="-1">taskQueue二叉堆实现思路 <a class="header-anchor" href="#taskqueue二叉堆实现思路" aria-label="Permalink to &quot;taskQueue二叉堆实现思路&quot;">​</a></h2><ol><li>使用<code>index=0</code>作为占位符，<code>root=1</code>为根节点，那么<code>children=2、3</code>对应的<code>children</code>为<code>(4, 5)</code>和<code>(6, 7)</code>，我们可以轻易算出<code>parent</code>和<code>children</code>之间的关系</li><li>涉及到上浮和下沉两种操作</li></ol><ul><li>当我们增加元素时，我们需要进行上浮不停对比<code>currentNode</code>和<code>parentNode</code>的关系，然后不停<code>swap</code>切换</li><li>当我们删除栈顶元素时，我们可以将末尾的元素换到栈顶，然后将整体长度size减去1，然后对目前新的栈顶元素进行下沉 <ul><li>需要比对<code>leftChild</code>和<code>rightChild</code>哪个比较小（最小堆），然后<code>swap</code>切换，然后将当前的index切换到<code>leftChild</code>/<code>rightChild</code>比较小的index</li><li>不停比对<code>currentNode</code>和<code>childLeftNode</code>/<code>childrightNode</code>，然后不停<code>swap</code>切换</li></ul></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在<code>ensureRootIsScheduled</code>的分析中，我们知道最终触发的下面的代码</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newCallbackNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    schedulerPriorityLevel,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    performConcurrentWorkOnRoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, root)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>其中，<code>scheduleCallback</code>触发的就是<code>newTask</code>加入到<code>taskQueue</code>或者<code>timerQueue</code>，然后触发对应的宏任务</p><p>而在宏任务中，我们会不断触发<code>task.callback</code>，然后判断是否有<code>hasWork</code>，如果有则继续触发宏任务，没有则结束！</p><p>而这里的<code>task.callback</code>即使上面代码中传入的<code>performConcurrentWorkOnRoot.bind(null, root)</code>!</p><p>因此我们认为<code>scheduleCallback</code>就是一个调度器，不停调度去处理<code>performConcurrentWorkOnRoot.bind(null, root)</code>执行！</p>',29)]))}const p=o(l,[["render",t]]);export{h as __pageData,p as default};
