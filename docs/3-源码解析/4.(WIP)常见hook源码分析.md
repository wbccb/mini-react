# 前言

在`React 18`中，我们详细分析了各种类型，比如`HostComponent`、`FunctionComponent`的初次渲染和渲染更新的流程，但是我们还没仔细分析过`React`重要的`React Hooks`相关源码
- 比如最常见的`useEffect()`
- 比如提供全局数据的`useContext()`
- 比如性能优化经常使用的`useMemo()`、`useCallback()`

在本文中，我们将针对这些常见的`hooks`，侧重于`useEffect()`和`useLayoutEffect()`，详细分析`React Hooks`初次渲染和渲染更新的流程


# 1. useEffect()

从下面`useEffect()`的使用中，我们可以知道，主要分为两个部分
- `()=> {}`: 回调函数
- `[color]`: 依赖项数组

```ts
useEffect(() => {
  console.log("useEffect 执行：当前颜色", color);
  // 模拟一个可能引起布局变化的操作（但会有延迟）
  const element = document.getElementById("box");
  if (element) {
    element.style.transform = "translateX(100px)";
  }
}, [color]);
```

而从`React 18`的源码中，我们可以发现，跟`useState()`类似，`useEffect()`也会根据初始化或者更新时选择不同的方法

```ts
var HooksDispatcherOnMount = {
  //...
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  //...
};
var HooksDispatcherOnUpdate = {
  //...
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  //...
};
```

初始化时，`useEffect`本质就是`mountEffect()`

更新时，`useEffect`本质就是`updateEffect()`


```ts
function mountEffect(create, deps) {
  return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(Passive, Passive$1, create, deps);
}
```


从`mountEffectImpl()`和`updateEffectImpl()`的代码可以知道，其实本质都是
- 使用`mountWorkInProgressHook()`或者`updateWorkInProgressHook()`获取当前的`hook`
- 更新阶段使用`areHookInputsEqual(nextDeps, prevDeps)`判断依赖是否已经改变，如果改变，则重新执行函数`create()`，重新赋值给`hook.memoizedState`
- 打上`flags`为`Passive`，为后面的`commit`阶段做准备

> 在下面的小节，我们将针对一些方法进行详细的分析

```ts
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HasEffect | hookFlags,
    create,
    undefined,
    nextDeps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var destroy = undefined;

  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;

    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }

  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HasEffect | hookFlags,
    create,
    destroy,
    nextDeps
  );
}
```

## 1.1 mountWorkInProgressHook

- 创建一个新的`hook`
- 如果当前fiber的hook集合，也就是`fiber.memoizedState`这个存储单链表数据为空，则进行头节点的赋值，否则进行`workInProgressHook.next = hook`构建单链表结构
- 最终返回当前fiber的hook集合的最后一个元素

```ts
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

## 1.2 updateWorkInProgressHook

### 1.1.3 pushEffect



# 2. useLayoutEffect()


# 3. useMemo()

# 4. useCallback()


# 5. useRef()


# 6. useContext()

## 6.1 Context

## 6.2 Provide