---
outline: [1, 6]
---



# 前言

在`React 18`中，我们详细分析了各种类型，比如`HostComponent`、`FunctionComponent`的初次渲染和渲染更新的流程，但是我们还没仔细分析过`React`重要的`React Hooks`相关源码
- 比如最常见的`useEffect()`
- 比如提供全局数据的`useContext()`
- 比如性能优化经常使用的`useMemo()`、`useCallback()`

在本文中，我们将针对这些常见的`hooks`，侧重于`useEffect()`和`useLayoutEffect()`，详细分析`React Hooks`初次渲染和渲染更新的流程


# 1. useEffect()

从下面`useEffect()`的使用中，我们可以知道，主要分为两个部分
- `()=> {}`: 回调函数
- `[color]`: 依赖项数组

```ts
useEffect(() => {
  console.log("useEffect 执行：当前颜色", color);
  // 模拟一个可能引起布局变化的操作（但会有延迟）
  const element = document.getElementById("box");
  if (element) {
    element.style.transform = "translateX(100px)";
  }
  return () => {
    console.log("Effect destroyed");
  };
}, [color]);
```

而从`React 18`的源码中，我们可以发现，跟`useState()`类似，`useEffect()`也会根据初始化或者更新时选择不同的方法

```ts
var HooksDispatcherOnMount = {
  //...
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  //...
};
var HooksDispatcherOnUpdate = {
  //...
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  //...
};
```

初始化时，`useEffect`本质就是`mountEffect()`

更新时，`useEffect`本质就是`updateEffect()`


```ts
function mountEffect(create, deps) {
  return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
}
function updateEffect(create, deps) {
  return updateEffectImpl(Passive, Passive$1, create, deps);
}
```

从`mountEffectImpl()`和`updateEffectImpl()`的代码可以知道，其实本质都是
- 使用`mountWorkInProgressHook()`或者`updateWorkInProgressHook()`获取当前的`hook`
- 更新阶段使用`areHookInputsEqual(nextDeps, prevDeps)`判断依赖是否已经改变，如果改变，则打上`HasEffect｜Passive`的`flags`，为后面的`commit`阶段做准备；如果依赖项没有改变，则打上`flags`为`Passive`，为后面的`commit`阶段做准备
- 最终还是需要执行一次`pushEffect()`重新构建一次`fiber.updateQueue`单循环链表结构
> 区别于依赖项改变，则传入`pushEffect()`的`hookFlags`不同

> 在下面的小节，我们将针对一些方法进行详细的分析

```ts
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HasEffect | hookFlags,
    create,
    undefined,
    nextDeps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var destroy = undefined;
  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HasEffect | hookFlags,
    create,
    destroy,
    nextDeps
  );
}
```

## 1.1 mountWorkInProgressHook

- 创建一个新的`hook`
- 如果当前fiber的hook集合，也就是`fiber.memoizedState`这个存储单链表数据为空，则进行头节点的赋值，否则进行`workInProgressHook.next = hook`构建单链表结构
- 最终返回当前fiber的hook集合的最后一个元素

```ts
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

## 1.2 updateWorkInProgressHook

在`hooks&更新渲染流程分析`的文章分析中，我们已经分析过`updateWorkInProgressHook()`获取当前fiber的hook

源码的代码过于繁琐和难以看懂，可以简化为下面代码
> 因为是更新阶段，一般alternate是存在的（可能存在之前没有hook，更新后又有hook，那么alternate就不存在）
>
> 这里考虑一般情况下=>可以简化代码逻辑，容易理解

由于是更新阶段，因此`currentlyRenderingFiber$1.alternate`必定存在，复用当前`alternate`的`memoizedState`构建链表数据，主要是`头节点的赋值`+`剩余节点的赋值`两个步骤

涉及到三个全局变量的赋值：

+ `currentHook`：代表的是当前`renderFiber.alternate`对应的`hook`
+ `currentlyRenderingFiber.memoizedState`：当前`renderFiber.alternate`复制的单链表
+ `workInProgressHook`：当前`renderFiber`对应的`hook`

> `fiber.memoizedState`跟`hook.memoizedState`是不一样的！！

```javascript
function updateWorkInProgressHook() {
	const current = currentlyRenderingFiber.alternate;
	if (workInProgressHook === null) {
		// 头节点还没赋值，获取当前fiber的alternate对应的单循环链表结构，因为是更新阶段，一般alternate是存在的（可能存在之前没有hook，更新后又有hook，那么alternate就不存在）
		currentlyRenderingFiber.memoizedState = current.memoizedState;
		workInProgressHook = currentlyRenderingFiber.memoizedState;
		currentHook = current.memoizedState;
	} else {
        // 当前fiber的下一个hook，因为一个fiber可能存在多个hook，会形成一个单循环链表结构
		workInProgressHook = workInProgressHook.next;
		currentHook = currentHook.next;
	}
	return workInProgressHook;
}
```

## 1.3 pushEffect重新构建fiber.updateQueue

传入的参数值中
- `tag`: `HasEffect | Passive`，`HasEffect`代表依赖项已经改变或者首次渲染，当检测到`HasEffect`，需要重新执行`create()`方法；`Passive`代表该fiber存在`hook`，在销毁时调用`effect.destory()`可以通过这个`flags`进行判断
- `create`: `useEffect(create, [deps])`的执行方法
- `destroy`: 在`commitHookEffectListMount()`中进行`destroy`=`create()`赋值（首次渲染阶段不会触发`destroy()`），它会在调用一个新的`effect`执行之前对前一个`effect`进行清理
- `deps`: `useEffect()`的依赖项，依赖项变化时，会重新执行传入的`create()`方法

> `destroy()`的执行将在下面的小节展开分析

`fiber.updateQueue`存放着`hook`的单链表数据，如果为空，则通过`createFunctionComponentUpdateQueue()`创建出新的`fiber.updateQueue`
> 注意：`fiber.updateQueue`是一个对象，具备`lastEffect`和`stores`两个属性

如果`fiber.updateQueue`已经初始化完成，则按照单链表的形式不断`next`即可
- `lastEffect`代表单链表的最后一个`hook`
- `firstEffect`代表单链表的最前面的一个`hook`
- `lastEffect.next`=`firstEffect`构成循环结构

```ts
function pushEffect(tag, create, destroy, deps) {
  var effect = {
    tag: tag,
    create: create,
    destroy: destroy,
    deps: deps,
    next: null,
  };
  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;

  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    var lastEffect = componentUpdateQueue.lastEffect;

    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      var firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }

  return effect;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
    stores: null,
  };
}
```

## 1.3 commit提交阶段处理effect

`commit阶段`最终是提交`fiber Root`的复制`fiber`进行提交，然后触发`finishConcurrentRender()`方法，从而最终触发`commitRootImpl()`方法

```javascript
var finishedWork = root.current.alternate;
root.finishedWork = finishedWork;
root.finishedLanes = lanes;
finishConcurrentRender(root, exitStatus, lanes);

function finishConcurrentRender(root, exitStatus, lanes) {
  switch (exitStatus) {
    //...
    case RootCompleted: {
      commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
      break;
    }
  }
}
function commitRoot(root, recoverableErrors, transitions) {
  //...
  commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);
}
```

而`commitRootImpl()`的核心代码如下所示：

+ 判断`subtreeHasEffects`（root元素的children存在`effect`/存在`Placement`等flags）和`rootHasEffect`（root元素存在`effect`/存在`Placement`等flags）然后调用
    - `commitBeforeMutationEffects()`
    - `commitMutationEffects()`
    - `commitLayoutEffects()`
+ 调用异步更新`ensureRootIsScheduled()`
+ 调用同步更新`flushSyncCallbacks()`
+ 微任务触发`flushPassiveEffects()`触发`effect`相关处理

```javascript
function commitRootImpl() {
    //...
    if (
        (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
        (finishedWork.flags & PassiveMask) !== NoFlags
    ) {
        if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback$2(NormalPriority, function () {
                flushPassiveEffects();
                return null;
            });
        }
    }
    var subtreeHasEffects =
        (finishedWork.subtreeFlags &
            (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
        NoFlags;
    var rootHasEffect =
        (finishedWork.flags &
            (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
        NoFlags;
    if (subtreeHasEffects || rootHasEffect) {
        const prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitBeforeMutationEffects(root, finishedWork);
        commitMutationEffects(root, finishedWork, lanes);
        commitLayoutEffects(finishedWork, root, lanes);
        executionContext = prevExecutionContext;
    } else {
        //...no effects
    }

    ensureRootIsScheduled(root, now());
    flushSyncCallbacks();
}
```

从上面代码可以看出
- 同步执行了`commitLayoutEffects()`，关联`LayoutEffect`相关逻辑
- 异步执行了`flushPassiveEffects()`，关联`Effect`相关逻辑


### 1.3.1 flushPassiveEffects()

由于`flushPassiveEffects()`的代码过于繁杂，使用一个流程图进行展示

![Image](https://github.com/user-attachments/assets/2a126f7d-a852-43bd-8c4b-13b16b0554da)

最终触发的是
- `commitHookEffectListUnmount()`: 触发`effect.destory()`
- `commitHookEffectListMount()`: 触发`effect.create()`


在删除fiber的逻辑中，使用`PassiveMask=Passive|ChildDeletion`作为判断触发`commitHookEffectListUnmount()`

在清除上一个effect的逻辑中，使用`Passive`作为判断来触发`commitPassiveUnmountOnFiber()`->`commitHookEffectListUnmount()`

在触发`effect.create()`时，先使用`PassiveMask`进行筛选，然后使用`Passive`作为判断来触发`commitPassiveMountOnFiber()`
```ts
function commitPassiveMountEffects_begin(
  subtreeRoot,
  root,
  committedLanes,
  committedTransitions
) {
  while (nextEffect !== null) {
    var fiber = nextEffect;
    var firstChild = fiber.child;

    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
      firstChild.return = fiber;
      nextEffect = firstChild;
    } else {
      commitPassiveMountEffects_complete(
        subtreeRoot,
        root,
        committedLanes,
        committedTransitions
      );
    }
  }
}
function commitPassiveMountEffects_complete(
  subtreeRoot,
  root,
  committedLanes,
  committedTransitions
) {
  while (nextEffect !== null) {
    var fiber = nextEffect;
    if ((fiber.flags & Passive) !== NoFlags) {
      commitPassiveMountOnFiber(
        root,
        fiber,
        committedLanes,
        committedTransitions
      );
    }
    if (fiber === subtreeRoot) {
      nextEffect = null;
      return;
    }
    var sibling = fiber.sibling;
    if (sibling !== null) {
      sibling.return = fiber.return;
      nextEffect = sibling;
      return;
    }
    nextEffect = fiber.return;
  }
}
```


<br/>

# 2. useLayoutEffect()

从下面代码可以看出，`useLayoutEffect()`与`useEffect()`的初始化流程几乎一模一样，区别在于传入的参数中
- `fiberFlags`为`Update`
- `hookFlags`为`Layout`

而`useEffect()`的传入参数为
- `fiberFlags`为`Passive`
- `hookFlags`为`Passive`

> 注：两个`Passive`为不同的数据...虽然名称一模一样

```ts
function mountLayoutEffect(create, deps) {
  var fiberFlags = Update;
  //...
  return mountEffectImpl(fiberFlags, Layout, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(Update, Layout, create, deps);
}
```

```ts
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = mountWorkInProgressHook();
    var nextDeps = deps === undefined ? null : deps;
    currentlyRenderingFiber$1.flags |= fiberFlags;
    hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = updateWorkInProgressHook();
    var nextDeps = deps === undefined ? null : deps;
    var destroy = undefined;

    if (currentHook !== null) {
        var prevEffect = currentHook.memoizedState;
        destroy = prevEffect.destroy;
        if (nextDeps !== null) {
            var prevDeps = prevEffect.deps;
            if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                return;
            }
        }
    }
    currentlyRenderingFiber$1.flags |= fiberFlags;
    hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
}
```


## 2.1 commit提交阶段处理commitLayoutEffects

从上面`useEffect()`的`commit阶段`分析可以知道，`commit阶段`最终是提交`fiber Root`的复制`fiber`进行提交，然后触发`finishConcurrentRender()`方法，从而最终触发`commitRootImpl()`方法

而`commitRootImpl()`的核心代码如下所示：

+ 判断`subtreeHasEffects`（root元素的children存在`effect`/存在`Placement`等flags）和`rootHasEffect`（root元素存在`effect`/存在`Placement`等flags）然后调用
    - `commitBeforeMutationEffects()`
    - `commitMutationEffects()`
    - `commitLayoutEffects()`
+ 调用异步更新`ensureRootIsScheduled()`
+ 调用同步更新`flushSyncCallbacks()`
+ 微任务触发`flushPassiveEffects()`触发`effect`相关处理

```ts
function commitLayoutEffects(finishedWork, root, committedLanes) {
  commitLayoutEffects_begin(finishedWork, root, committedLanes);
}
function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {
  while (nextEffect !== null) {
    var fiber = nextEffect;
    var firstChild = fiber.child;
    //...
    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
      // LayoutMask = Update | Callback | Ref | Visibility
      firstChild.return = fiber;
      nextEffect = firstChild;
    } else {
      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
    }
  }
}
function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {
  while (nextEffect !== null) {
    var fiber = nextEffect;
    if ((fiber.flags & LayoutMask) !== NoFlags) {
      var current = fiber.alternate;
      commitLayoutEffectOnFiber(root, current, fiber, committedLanes);
    }
    if (fiber === subtreeRoot) {
      nextEffect = null;
      return;
    }
    var sibling = fiber.sibling;
    if (sibling !== null) {
      sibling.return = fiber.return;
      nextEffect = sibling;
      return;
    }
    nextEffect = fiber.return;
  }
}
```

主要逻辑还是封装在`commitLayoutEffectOnFiber()`中，也是根据不同的`fiber.tag`进行不同方法的调用
- `FunctionComponent`: 触发`commitHookEffectListMount()`
- `ClassComponent`: 先触发`componentDidMount`/`componentDidUpdate`，然后触发`commitUpdateQueue()`
- `HostRoot`: 触发`commitUpdateQueue()`
- `HostComponent`: 触发`commitMount()`

```ts
function commitLayoutEffectOnFiber() {
  if ((finishedWork.flags & LayoutMask) !== NoFlags) {
    switch (finishedWork.tag) {
      case FunctionComponent:
      case ForwardRef:
      case SimpleMemoComponent: {
        if (!offscreenSubtreeWasHidden) {
          commitHookEffectListMount(Layout | HasEffect, finishedWork);
        }
        break;
      }
      case ClassComponent: {
        var instance = finishedWork.stateNode;
        if (finishedWork.flags & Update) {
          if (!offscreenSubtreeWasHidden) {
            if (current === null) {
              instance.componentDidMount();
            } else {
              var prevProps =
                finishedWork.elementType === finishedWork.type
                  ? current.memoizedProps
                  : resolveDefaultProps(
                      finishedWork.type,
                      current.memoizedProps
                    );
              var prevState = current.memoizedState; // We could update instance props and state here,
              instance.componentDidUpdate(
                prevProps,
                prevState,
                instance.__reactInternalSnapshotBeforeUpdate
              );
            }
          }
        }
        var updateQueue = finishedWork.updateQueue;
        if (updateQueue !== null) {
          commitUpdateQueue(finishedWork, updateQueue, instance);
        }

        break;
      }

      case HostRoot: {
        var _updateQueue = finishedWork.updateQueue;

        if (_updateQueue !== null) {
          var _instance = null;

          if (finishedWork.child !== null) {
            switch (finishedWork.child.tag) {
              case HostComponent:
                _instance = getPublicInstance(finishedWork.child.stateNode);
                break;
              case ClassComponent:
                _instance = finishedWork.child.stateNode;
                break;
            }
          }
          commitUpdateQueue(finishedWork, _updateQueue, _instance);
        }
        break;
      }
      case HostComponent: {
        var _instance2 = finishedWork.stateNode;
        if (current === null && finishedWork.flags & Update) {
          var type = finishedWork.type;
          var props = finishedWork.memoizedProps;
          commitMount(_instance2, type, props);
        }
        break;
      }
      case HostText: {
        // We have no life-cycles associated with text.
        break;
      }
    }
  }
  if (!offscreenSubtreeWasHidden) {
    if (finishedWork.flags & Ref) {
      commitAttachRef(finishedWork);
    }
  }
}
```


### 2.1.1 commitHookEffectListMount()

```ts
function commitHookEffectListMount(flags, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;
    do {
      if ((effect.tag & flags) === flags) {
        var create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
```

从`fiber.updateQueue`取出当前fiber的hook单循环链表数据，不断遍历取出对应`create`方法执行，然后返回对应的destroy方法给`hook.destory`
> create()就是下面`useEffect(fn, [color])`的fn，destroy就是返回的`console.log("Effect destroyed")`对应的方法

```ts
useEffect(() => {
  return () => {
    console.log("Effect destroyed");
  };
}, [color]);
```


### 2.1.2 commitMount()

进行`dom.focus()`或者`dom.src`的赋值

```ts
function commitMount(domElement, type, newProps, internalInstanceHandle) {
  switch (type) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      if (newProps.autoFocus) {
        domElement.focus();
      }
      return;
    case "img": {
      if (newProps.src) {
        domElement.src = newProps.src;
      }
      return;
    }
  }
}
```

### 2.1.3 commitUpdateQueue()

我们从上面的分析可以知道，`ClassComponent`会先触发`componentDidMount`/`componentDidUpdate`，然后触发`commitUpdateQueue()`

我们可以构建一个如下的示例，当点击按钮触发`this.setState()`时会触发`commitUpdateQueue()`，如下面截图所示
```js
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick = () => {
    // 触发 setState 并传入回调函数
    this.setState({ count: this.state.count + 1 }, () => {
      console.error("Effect.callback executed!", this.state.count);
    });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.handleClick}>Increment</button>
      </div>
    );
  }
}
```

![Image](https://github.com/user-attachments/assets/99e2233e-5a19-4cf0-a325-23ad4103bc65)


> 而`setState`的回调什么时候放入到`effect.callback`中呢？
>
> 在下面的小节我们将简单分析下`ClassComponent的setState`流程

## 2.2 ClassComponent的setState()

从下面代码我们可以看出，`setState()`传入的回调放在了`update.callback`中

```ts
Component.prototype.setState = function (partialState, callback) {
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
var classComponentUpdater = {
  isMounted: isMounted,
  enqueueSetState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.payload = payload;
    if (callback !== undefined && callback !== null) {
      update.callback = callback;
    }

    var root = enqueueUpdate$1(fiber, update, lane);
    if (root !== null) {
      scheduleUpdateOnFiber(root, fiber, lane, eventTime);
      entangleTransitions(root, fiber, lane);
    }
  },
};
```

> 那么`update.callback`是什么时候转移到`fiber.updateQueue.callback`中呢？

如下图所示，在`beginWork()`->`case ClassComponent: 触发updateClassComponent()`->`processUpdateQueue()`

在`processUpdateQueue()`中，会将`update`放入到`fiber.updateQueue.effects`中

![Image](https://github.com/user-attachments/assets/cb72fc17-d69b-4d34-bc07-fda6a4a8728b)


而在上面的Commit阶段中，我们会触发`commitUpdateQueue()`，如下面代码所示，也就是从`fiber.updateQueue`取出`effects`然后进行处理
![Image](https://github.com/user-attachments/assets/99e2233e-5a19-4cf0-a325-23ad4103bc65)

```ts
function commitUpdateQueue(finishedWork, finishedQueue, instance) {
    // Commit the effects
    var effects = finishedQueue.effects;
    finishedQueue.effects = null;

    if (effects !== null) {
        for (var i = 0; i < effects.length; i++) {
            var effect = effects[i];
            var callback = effect.callback;

            if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
            }
        }
    }
}
``` 

至此，我们弄清楚了`ClassComponent`中如何触发`LayoutEffect`以及`setState`会触发什么流程的大体逻辑
 
<br/>

# 3. useMemo()

<br/>

# 4. useCallback()

<br/>

# 5. useRef()

<br/>

# 6. useContext()

## 6.1 Context

## 6.2 Provide