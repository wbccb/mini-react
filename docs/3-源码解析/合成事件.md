# 前言

### React 18.3.1 使用合成事件的核心原因

#### 1. 统一浏览器行为
不同浏览器（如 IE、Chrome、Firefox）对原生事件（如 focus、scroll）的实现差异较大，合成事件通过标准化 API 屏蔽底层差异，确保跨浏览器一致性。

#### 2. 优化事件系统架构
React 需要将事件逻辑与组件生命周期、虚拟 DOM 更新深度绑定，合成事件为 React 提供了可控制的事件流机制。

-------------------

### 合成事件的核心优势

#### 1. 跨浏览器一致性
- **标准化 API**: 无论用户使用何种浏览器，合成事件（如 onClick、onChange）的行为和属性完全一致。
- **修复浏览器差异**: 例如，onScroll 在原生事件中不冒泡，但 React 通过合成事件模拟冒泡逻辑，使其行为更符合开发者直觉。

#### 2. 性能优化
- **事件委托（Event Delegation）**: React 17+ 将事件统一绑定到应用根容器（如 #root），而非每个 DOM 节点，大幅减少内存占用和绑定开销。
- **自动清理监听器**:  组件卸载时，React 自动解除相关事件监听，避免内存泄漏（无需手动 removeEventListener）。

#### 3. 对 React 生态的深度集成
- **与组件生命周期同步**:  合成事件的处理逻辑会考虑组件状态（如异步更新的 setState），避免因事件触发时组件已卸载导致的错误。
- **支持批量更新**:  在合成事件回调中的状态更新会自动合并为批量更新，减少不必要的渲染。

#### 4. 未来兼容性与扩展性
- **渐进式升级**:  合成事件系统使 React 能独立于浏览器演进，例如 React 17 将事件委托目标从 document 改为根容器，解决微前端场景下的多应用冲突。
- **自定义事件支持**:  开发者可通过合成事件系统扩展自定义事件（如长按、手势），无需依赖第三方库。

#### 5. 开发体验提升
- **异步访问事件属性**:  React 17+ 移除了事件池（Event Pooling），开发者无需调用 e.persist() 即可在异步代码中直接使用事件对象。
- **更直观的冒泡行为**:  修正了原生事件中 onFocus/onBlur 不冒泡的问题，改用 onFocusIn/onFocusOut 模拟冒泡，逻辑更统一。


# 整体流程图


# 合成事件注册

